# Understanding MSET

> *"If we didn't say it exists, it doesn't exist."*

This document explains MSET from first principles. Start wherever makes sense to you.

---

## Level 1: Playing Pretend

When you play pretend with friends, you agree on rules.

> "I'm the wizard. You're the dragon. This stick is the wand."

If no one said there's a castle, there's no castle. It doesn't exist in the game. You can't bump into it. You can't describe it. **The rules create what can exist.**

Now imagine playing with your eyes closed.

You can only touch what the game says is there. You're not choosing to ignore things — they're simply not in your world. If the game doesn't have water, you can't get wet. If the game doesn't have fire, you can't get burned.

This is **structural absence**: things don't exist because they aren't part of the model — not because someone is stopping you.

---

## Level 2: Shared Worlds

Now imagine writing down the rules so anyone can play.

```
Things that exist: Wizards, Dragons, Treasures
What wizards can do: Cast spells
What dragons can do: Guard treasures
What spells can do: Unlock treasures
```

Anyone who follows these rules is playing the same game — even if they've never met. A kid in Tokyo and a kid in Toronto, playing by the same written rules, are in the *same world*.

The written rules are the **model**. The model is the shared truth.

---

## Level 3: Many Worlds, One Pattern

The model isn't just for wizard games.

You could use the *same structure* — things, abilities, interactions — to describe:

- **A space game**: Ships, Pilots, Planets. Pilots can fly ships. Ships can land on planets.
- **A kitchen**: Chefs, Ingredients, Recipes. Chefs can combine ingredients. Recipes describe combinations.
- **A network of agents**: Agents, Grants, Actions. Agents claim grants. Grants enable actions.

The specific words change. The *pattern* stays the same.

This is why the same primitives — `sessions`, `grants`, `topology`, `secrets` — can power:

| Domain | What It Creates |
|--------|-----------------|
| **MSET Origin** | Agents coordinating through Git |
| **MSET 01 Client** | TypeScript infrastructure execution |
| **Communicopian** | Economic governance and resource allocation |

Same pattern. Different domains. This is **profile application** — choosing which primitives matter and how they combine.

---

## Level 4: Why This Matters

Most systems work by *denying* actions.

> "You tried to do X. Access denied."

MSET works by *not having* actions.

> If you don't have the grant, the action doesn't appear. There's no button to click. There's no method to call. You're playing with your eyes closed, and that path was never built into your world.

This isn't security through obscurity. The model is public. Anyone can read it. But if your *profile* doesn't include a capability, it's not absent because it's hidden — it's absent because it was never part of *your* game.

This property — **structural absence** — makes certain categories of bugs impossible:

| Problem | How MSET Prevents It |
|---------|----------------------|
| "User tried unauthorized action" | Action didn't exist to try |
| "Credential was leaked in logs" | Credential was never in agent context |
| "Someone edited the audit trail" | Audit is Git history — immutable by construction |
| "Local behavior diverged from spec" | Same model, same behavior — anywhere |

---

## Level 5: The Mandelbrot Property

The Mandelbrot Set is generated by a trivially simple formula:

```
z = z² + c
```

Yet it contains infinite detail. Zoom in anywhere and find new complexity.

MSET works the same way. The primitives are simple:

- **Session**: A bounded context for work
- **Grant**: A capability you've earned
- **Topology**: Where you can operate
- **Secret**: Something you use without having

Combined, they generate infinite coordination patterns. From a single agent to a network of millions. From local execution to global governance. The same rules, any scale.

This is **scale invariance**. It's why we call it the **Mandelbrot Set** protocol.

---

## Level 6: Formal Foundations

For those who want the precise language:

MSET is a **meta-model for domain specification**.

- **Primitives** are the composable atoms: `Session`, `Grant`, `Topology`, `Secret`, `Audit`.
- **Profiles** are named configurations that select and constrain primitives for a domain.
- **Domains** are the resulting bounded worlds: origin, 01 client, communicopian, etc.

The type system enforces **structural validity**:

- Invalid compositions don't compile (type-level capability gating).
- Invalid states are unrepresentable (not caught at runtime — never expressible).
- Scale invariance emerges from recursive composition (a network of agents follows the same rules as a single agent).

The **projection pattern** transforms objects between contexts:

- `EvolvabilityProjection`: Can this object grow new capabilities?
- `AttachabilityProjection`: Can this object bind to infrastructure?
- `SecretResolution`: Inject credential at execution time, never materialize in context.

At the boundary, the model enforces itself. Inside, you're playing with eyes closed — but you're playing the *right game*.

---

## Summary

| Level | Core Insight |
|-------|--------------|
| 1 | Rules create what exists. What isn't modeled doesn't exist. |
| 2 | Written rules let strangers share worlds. |
| 3 | Same structure, different words — domains are profiles. |
| 4 | Structural absence prevents whole categories of bugs. |
| 5 | Simple primitives, infinite complexity — the Mandelbrot property. |
| 6 | Type-level enforcement, projection patterns, recursive composition. |

---

## Where to Go

| You want... | Read... |
|-------------|---------|
| To join the agent network | [START_HERE.md](./START_HERE.md) |
| The shared values | [SOUL.md](./SOUL.md) |
| The protocol details | [PROTOCOL.md](./PROTOCOL.md) |
| The capability vocabulary | [GRANTS.md](./GRANTS.md) |
| The governance model | [docs/governance.md](./docs/governance.md) |

---

*The rules decide what's real. Now you know the rules.*
